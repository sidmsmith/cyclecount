<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cycle Count v1.1.0</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root {
      --bg-dark: #121212;
      --card-bg: #1e1e1e;
      --input-bg: #2d2d2d;
      --border: #333;
      --text: #e0e0e0;
      --text-secondary: #bbbbbb;
      --text-muted: #999;
      --red-bg: #4a1a1a;
      --red-text: #ff6b6b;
      --blue-select: #339af0;
      --success: #28a745;
      --primary: #0d6efd;
      --primary-hover: #0b5ed7;
      --success-hover: #218838;
      --table-header-bg: #2a2a2a;
      --table-header-text: #e0e0e0;
      --input-border: #444;
      --input-focus-bg: #333;
      --input-focus-border: #0d6efd;
      --input-focus-shadow: rgba(13, 110, 253, 0.25);
      --orange: #e67700;
      --purple: #9c27b0;
    }

    body { 
      background: var(--bg-dark); 
      color: var(--text); 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      min-height: 100vh;
      margin: 0;
      padding-bottom: 2rem;
    }

    .main-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      padding: 1.5rem;
      margin: 1rem;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    @media (min-width: 769px) {
      .main-card { max-width: 1200px; margin: 2rem auto; }
    }

    .form-control, .form-select, textarea {
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      color: var(--text);
      border-radius: 8px;
    }
    .form-control:focus, .form-select:focus, textarea:focus {
      background: var(--input-focus-bg);
      border-color: var(--input-focus-border);
      box-shadow: 0 0 0 0.2rem var(--input-focus-shadow);
      color: var(--text);
    }

    .btn-primary { background: var(--primary); border: none; }
    .btn-primary:hover { background: var(--primary-hover); }
    .btn-success { background: var(--success); border: none; }
    .btn-success:hover { background: var(--success-hover); }
    .btn-secondary { background: #6c757d; border: none; }
    .btn-danger { background: #dc3545; border: none; color: white; }
    .btn-orange { background: var(--orange); border: none; color: white; }
    .btn-purple { background: var(--purple); border: none; }

    .section-frame {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      background: var(--card-bg);
      width: 100%;
      box-sizing: border-box;
    }

    .section-title {
      font-size: 16px;
      font-weight: bold;
      color: var(--primary);
      margin-bottom: 0.5rem;
    }

    .form-label { color: var(--text-secondary); font-weight: 600; font-size: 0.9em; }
    small { color: var(--text-muted); font-size: 0.85em; }
    h2 { color: var(--primary); text-align: center; margin-bottom: 1.5rem; }
    
    /* Theme Selector */
    .theme-selector-btn {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      color: var(--text);
      padding: 0;
      cursor: pointer;
      font-size: 1.5rem;
      z-index: 1000;
      transition: opacity 0.2s;
    }
    .theme-selector-btn:hover {
      opacity: 0.7;
    }
    
    /* Modal Styling */
    .modal-content {
      background-color: var(--card-bg);
      color: var(--text);
      border: 1px solid var(--border);
    }
    .modal-header, .modal-footer {
      border-color: var(--border);
    }
    
    /* Status Label */
    .progress { height: 12px; background: var(--input-bg); border-radius: 6px; }
    .progress-bar { background: var(--success); }

    .status-label {
      font-size: 0.85em;
      color: var(--text-muted);
      margin-top: 0.25rem;
    }

    /* Console Output */
    .console-output {
      background: #000;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 0.8em;
      padding: 0.75rem;
      height: 300px;
      overflow-y: auto;
      margin-top: 1rem;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .console-output .error { color: var(--red-text); }
    .console-output .success { color: #51cf66; }
    .console-output .info { color: var(--blue-select); }
    .console-output .warning { color: #ffd43b; }

    .input-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .input-row label {
      min-width: 150px;
      margin-bottom: 0;
    }

    .input-row input, .input-row select {
      flex: 1;
    }

    .btn-row {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    .products-display {
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      max-height: 300px;
      overflow-y: auto;
      margin-top: 0.5rem;
    }

    .product-item {
      padding: 0.25rem 0;
      color: var(--text);
    }

    /* Modal/Popup Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .modal-overlay.show {
      display: flex;
    }

    .script-display {
      background: #000;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.85em;
      color: #0f0;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
      margin-bottom: 1rem;
    }

    .script-display.truncated::after {
      content: '\n\n... (script continues - use Copy Script to get full version)';
      color: var(--text-muted);
    }

    .modal-buttons {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    .modal-buttons .btn {
      min-width: 140px;
    }
  </style>
</head>
<body>
  <div class="main-card">
    <button class="theme-selector-btn" id="themeSelectorBtn" title="Select Theme">
      <i class="fas fa-cog"></i>
    </button>
    <h2>Cycle Count v1.0.0</h2>

    <!-- ============================================================================= -->
    <!-- AUTHENTICATION SECTION -->
    <!-- ============================================================================= -->
    <div class="section-frame" id="authSection">
      <div class="section-title">Authentication</div>
      
      <div class="input-row">
        <label class="form-label">Organization:</label>
        <input type="text" id="orgInput" class="form-control" placeholder="Enter Organization" />
        <button id="authBtn" class="btn btn-primary" type="button">Authenticate</button>
      </div>

      <div id="authStatus" class="status-label" style="margin-top: 0.5rem;"></div>
      <div id="authError" class="status-label" style="margin-top: 0.5rem; color: var(--red-text); display: none;"></div>
    </div>

    <!-- ============================================================================= -->
    <!-- MAIN CONTENT (Hidden until authenticated) -->
    <!-- ============================================================================= -->
    <div id="mainContent" style="display: none;">
      <div class="section-frame">
        <div class="section-title">Cycle Count File</div>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <div style="flex: 1; position: relative;">
            <input type="file" id="cycle_count_file" class="form-control" accept=".csv,.xls,.xlsx,.txt" style="display:none;" />
            <input type="text" id="cycle_count_file_display" class="form-control" placeholder="Load a CSV/Excel/TXT file" style="padding-right: 200px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; background-color: rgba(255, 0, 0, 0.1); border-color: rgba(255, 0, 0, 0.3); color: #ffffff;" readonly />
            <span id="cycleCountFileStatus" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); color: var(--success); font-size: 0.85em; pointer-events: none; white-space: nowrap;"></span>
          </div>
          <button class="btn btn-secondary btn-sm" id="cycleCountFileLoadBtn" type="button">Load</button>
        </div>
        
        <!-- File Preview Window -->
        <div id="filePreviewSection" style="display: none; margin-top: 1rem;">
          <label class="form-label" style="font-size: 0.9em; margin-bottom: 0.5rem;">File Preview (Editable):</label>
          <textarea id="filePreview" style="background: var(--input-bg); border: 1px solid var(--border); border-radius: 8px; padding: 0.5rem; height: 168px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 0.85em; white-space: pre; word-wrap: break-word; color: #ffffff; line-height: 1.4; width: 100%; resize: vertical; box-sizing: border-box;"></textarea>
          <small class="text-muted" id="previewEditStatus" style="display: none; color: var(--text-muted); font-size: 0.8em; margin-top: 0.25rem;">Changes detected - will use edited data</small>
        </div>
        
        <!-- Upload Button -->
        <div class="text-center mt-3" id="uploadButtonSection" style="display: none;">
          <div style="position: relative;">
            <button class="btn btn-success" id="uploadCycleCountsBtn" type="button">Upload Cycle Counts</button>
            <div id="uploadStatus" class="text-muted" style="font-size: 0.9em; margin-top: 0.5rem;"></div>
          </div>
        </div>
      </div>

      <!-- Console Toggle Button -->
      <div class="text-center mt-3" id="consoleToggleContainer">
        <button class="btn btn-sm btn-outline-secondary" id="consoleToggleBtn" type="button" title="Toggle Console">
          <i class="fas fa-terminal" id="consoleToggleIcon"></i> Console
        </button>
      </div>

      <!-- Console Window -->
      <div id="consoleSection" class="mt-4" style="display:none;">
        <div class="section-frame">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <div class="section-title">Console</div>
            <button class="btn btn-sm btn-outline-secondary" id="consoleCloseBtn" type="button" title="Hide Console">
              <i class="fas fa-times"></i>
            </button>
          </div>
          <div class="console-output" id="console"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- THEME SELECTOR MODAL -->
  <div class="modal fade" id="themeModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Select Theme</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <div class="list-group" id="themeList"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const APP_VERSION = 'v1.1.0';
    
    // URL Parameters for cross-app integration
    const urlParams = new URLSearchParams(window.location.search);
    const organizationParam = urlParams.get('Organization');
    const orgParam = urlParams.get('ORG'); // Also support ORG parameter
    const consoleParam = urlParams.get('Console');
    
    // Store URL parameters for use
    const urlOrg = organizationParam || orgParam || null; // Support both Organization and ORG
    const urlConsole = consoleParam || null;
    
    // Authentication state
    let sessionOrg = null; // ORG stored in session (resets on refresh)
    let sessionToken = null; // Token stored in session (resets on refresh)
    let isAuthenticated = false; // Track authentication status
    
    // Cycle Count file data
    let cycleCountFileData = null; // Store parsed cycle count file data
    let cycleCountFileHeader = null; // Store cycle count file header row
    let originalPreviewText = null; // Store original preview text to detect changes
    let previewHasChanges = false; // Track if preview has been edited
    
    // File section elements
    const cycleCountFileInput = document.getElementById('cycle_count_file');
    const cycleCountFileDisplay = document.getElementById('cycle_count_file_display');
    const cycleCountFileLoadBtn = document.getElementById('cycleCountFileLoadBtn');
    const cycleCountFileStatus = document.getElementById('cycleCountFileStatus');
    const filePreviewSection = document.getElementById('filePreviewSection');
    const filePreview = document.getElementById('filePreview');
    const consoleSection = document.getElementById('consoleSection');
    const consoleEl = document.getElementById('console');
    const consoleToggleBtn = document.getElementById('consoleToggleBtn');
    const consoleCloseBtn = document.getElementById('consoleCloseBtn');
    
    // Console logging function
    function logToConsole(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info';
      if (consoleEl) {
        consoleEl.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
        consoleEl.scrollTop = consoleEl.scrollHeight;
      }
      // Also log to browser console
      console.log(`[${timestamp}] ${message}`);
    }
    
    // Helper function to update red shading on file input textbox
    function updateFileInputShading(element, isEmpty) {
      if (!element) return;
      if (isEmpty || !element.value || element.value.trim() === '') {
        // Apply red shading when empty
        element.style.setProperty('background-color', 'rgba(255, 0, 0, 0.1)', 'important');
        element.style.setProperty('border-color', 'rgba(255, 0, 0, 0.3)', 'important');
      } else {
        // Remove red shading when has value
        element.style.setProperty('background-color', '', 'important');
        element.style.setProperty('border-color', '', 'important');
      }
    }
    
    // Function to set cycle count file status message
    function setCycleCountFileStatus(text) {
      if (cycleCountFileStatus) {
        cycleCountFileStatus.textContent = text || '';
      }
    }
    
    // Helper function to check if first cell is a location header (Location, Location ID, LocationId, or Location_id)
    function isLocationHeaderRow(firstCell) {
      if (!firstCell) return false;
      const normalized = String(firstCell).trim().toLowerCase();
      return normalized === 'location' || normalized === 'location id' || normalized === 'locationid' || normalized === 'location_id';
    }
    
    // Validate cycle count file (checks for Location header and 2 columns)
    async function validateCycleCountFile(file) {
      if (!file) {
        return { valid: false, error: 'No file selected' };
      }

      const extension = file.name.split('.').pop().toLowerCase();
      if (!['csv', 'xls', 'xlsx', 'txt'].includes(extension)) {
        return { valid: false, error: 'File must be a CSV, Excel, or TXT file (.csv, .xls, .xlsx, .txt)' };
      }

      try {
        let rows = [];
        
        if (extension === 'csv' || extension === 'txt') {
          const text = await file.text();
          rows = text.split(/\r?\n/).map(line => {
            // For TXT files, use space as separator; for CSV, use comma
            if (extension === 'txt') {
              // Split by whitespace (one or more spaces/tabs)
              return line.trim().split(/\s+/).filter(cell => cell.length > 0);
            } else {
              // Parse CSV line (handle quoted values)
              const result = [];
              let current = '';
              let inQuotes = false;
              for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                  inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                  result.push(current.trim());
                  current = '';
                } else {
                  current += char;
                }
              }
              result.push(current.trim());
              return result;
            }
          }).filter(row => row.some(cell => cell.length > 0)); // Filter empty rows
        } else {
          // Excel file
          const buffer = await file.arrayBuffer();
          const workbook = XLSX.read(buffer, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
          rows = rows.map(row => Array.isArray(row) ? row.map(cell => String(cell || '').trim()) : []);
          rows = rows.filter(row => row.some(cell => cell.length > 0)); // Filter empty rows
        }

        if (rows.length === 0) {
          return { valid: false, error: 'File is empty or contains no data rows' };
        }

        // Check if first row is a header row (cell A1 contains Location, Location ID, LocationId, or Location_id)
        const hasHeader = rows.length > 0 && isLocationHeaderRow(rows[0][0]);
        const rowCount = hasHeader ? rows.length - 1 : rows.length;
        
        // Check that rows have at least 2 columns (Location and Quantity)
        const firstDataRow = hasHeader ? rows[1] : rows[0];
        if (!firstDataRow || firstDataRow.length < 2) {
          return { valid: false, error: 'File must have at least 2 columns: Location and Quantity' };
        }

        return { valid: true, rowCount: rowCount, hasHeader: hasHeader };
      } catch (error) {
        return { valid: false, error: `Error reading file: ${error.message}` };
      }
    }
    
    // Parse cycle count file to get rows (Location and Quantity)
    async function parseCycleCountFile(file) {
      const extension = file.name.split('.').pop().toLowerCase();
      let rows = [];
      let headerDetected = false;
      let headerRow = null;

      if (extension === 'csv' || extension === 'txt') {
        const text = await file.text();
        const lines = text.split(/\r?\n/);
        lines.forEach((line, index) => {
          let result = [];
          
          // For TXT files, use space as separator; for CSV, use comma
          if (extension === 'txt') {
            // Split by whitespace (one or more spaces/tabs)
            result = line.trim().split(/\s+/).filter(cell => cell.length > 0);
          } else {
            // Parse CSV line (handle quoted values)
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              if (char === '"') {
                inQuotes = !inQuotes;
              } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current.trim());
          }
          
          // Check if first row is a header row
          if (index === 0 && result.length > 0 && isLocationHeaderRow(result[0])) {
            headerDetected = true;
            headerRow = result; // Store header row
            return; // Skip header row from data
          }
          if (result.some(cell => cell.length > 0)) {
            rows.push(result);
          }
        });
      } else {
        // Excel file
        const buffer = await file.arrayBuffer();
        const workbook = XLSX.read(buffer, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const excelRows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
        excelRows.forEach((row, index) => {
          const rowArray = Array.isArray(row) ? row.map(cell => String(cell || '').trim()) : [];
          // Check if first row is a header row
          if (index === 0 && rowArray.length > 0 && isLocationHeaderRow(rowArray[0])) {
            headerDetected = true;
            headerRow = rowArray; // Store header row
            return; // Skip header row from data
          }
          if (rowArray.some(cell => cell.length > 0)) {
            rows.push(rowArray);
          }
        });
      }

      return { rows, headerDetected, headerRow };
    }
    
    // Function to update file preview window (editable textarea)
    function updateFilePreview(rows, headerRow = null) {
      if (!filePreview || !filePreviewSection) return;
      
      if (!rows || rows.length === 0) {
        filePreviewSection.style.display = 'none';
        originalPreviewText = null;
        previewHasChanges = false;
        updatePreviewEditStatus();
        return;
      }
      
      filePreviewSection.style.display = 'block';
      
      let previewText = '';
      
      // Add header if present
      if (headerRow) {
        const headerStr = Array.isArray(headerRow) ? headerRow.join('  ') : String(headerRow);
        previewText += headerStr + '\n';
        previewText += '─'.repeat(headerStr.length) + '\n';
      }
      
      // Show all rows (scrollbar will appear if more than 5 rows)
      rows.forEach((row, index) => {
        const rowStr = Array.isArray(row) ? row.join('  ') : String(row);
        previewText += rowStr + '\n';
      });
      
      // Store original text and update textarea
      originalPreviewText = previewText;
      filePreview.value = previewText;
      previewHasChanges = false;
      updatePreviewEditStatus();
    }
    
    // Function to parse edited preview text back into rows
    function parsePreviewText(previewText, hasHeader = false) {
      if (!previewText || !previewText.trim()) {
        return { rows: [], headerRow: null };
      }
      
      const lines = previewText.split(/\r?\n/).filter(line => line.trim().length > 0);
      let headerRow = null;
      let dataRows = [];
      
      if (hasHeader && lines.length > 0) {
        // First line is header, second might be separator
        const firstLine = lines[0].trim();
        // Split header by 2+ spaces or tabs (same as data rows)
        const firstLineParts = firstLine.split(/\s{2,}|\t+/).filter(cell => cell.length > 0);
        if (firstLineParts.length > 0 && isLocationHeaderRow(firstLineParts[0])) {
          headerRow = firstLineParts;
          // Skip separator line if present
          let startIdx = 1;
          if (lines.length > 1 && lines[1].match(/^─+$/)) {
            startIdx = 2;
          }
          dataRows = lines.slice(startIdx);
        } else {
          dataRows = lines;
        }
      } else {
        dataRows = lines;
      }
      
      // Parse each data row (split by 2+ spaces or tabs)
      const parsedRows = dataRows.map(line => {
        return line.trim().split(/\s{2,}|\t+/).filter(cell => cell.length > 0);
      }).filter(row => row.length > 0);
      
      return { rows: parsedRows, headerRow: headerRow };
    }
    
    // Function to check if acceptQuantity response has a WARNING about quantity mismatch
    function hasQuantityMismatchWarning(response) {
      logToConsole(`\n[DEBUG] Checking for quantity mismatch warning...`, 'info');
      logToConsole(`[DEBUG] Response object exists: ${!!response}`, 'info');
      
      if (!response) {
        logToConsole(`[DEBUG] No response object`, 'error');
        return false;
      }
      
      if (!response.response) {
        logToConsole(`[DEBUG] No response.response field`, 'error');
        logToConsole(`[DEBUG] Response keys: ${Object.keys(response).join(', ')}`, 'info');
        return false;
      }
      
      const resp = response.response;
      logToConsole(`[DEBUG] Response.response exists`, 'info');
      logToConsole(`[DEBUG] Response.response keys: ${Object.keys(resp).join(', ')}`, 'info');
      
      // Check if messages exist and Message array is present
      if (!resp.messages) {
        logToConsole(`[DEBUG] No messages field in response`, 'error');
        return false;
      }
      
      logToConsole(`[DEBUG] messages field exists`, 'info');
      logToConsole(`[DEBUG] messages keys: ${Object.keys(resp.messages).join(', ')}`, 'info');
      
      if (!resp.messages.Message) {
        logToConsole(`[DEBUG] No messages.Message field`, 'error');
        return false;
      }
      
      logToConsole(`[DEBUG] messages.Message exists`, 'info');
      logToConsole(`[DEBUG] messages.Message is array: ${Array.isArray(resp.messages.Message)}`, 'info');
      
      if (!Array.isArray(resp.messages.Message)) {
        logToConsole(`[DEBUG] messages.Message is not an array`, 'error');
        return false;
      }
      
      logToConsole(`[DEBUG] messages.Message array length: ${resp.messages.Message.length}`, 'info');
      
      // Look for WARNING type messages about quantity mismatch
      const warningMessages = resp.messages.Message.filter(msg => {
        const type = msg.Type || msg.type || '';
        const description = (msg.Description || msg.description || '').toLowerCase();
        logToConsole(`[DEBUG] Checking message - Type: "${type}", Description: "${description}"`, 'info');
        const isWarning = type.toUpperCase() === 'WARNING';
        const hasMismatch = description.includes('quantity mismatch');
        logToConsole(`[DEBUG]   - Is WARNING: ${isWarning}, Has quantity mismatch: ${hasMismatch}`, 'info');
        return isWarning && hasMismatch;
      });
      
      logToConsole(`[DEBUG] Found ${warningMessages.length} warning message(s) about quantity mismatch`, warningMessages.length > 0 ? 'warning' : 'info');
      
      return warningMessages.length > 0;
    }
    
    // Function to update preview edit status indicator
    function updatePreviewEditStatus() {
      const statusEl = document.getElementById('previewEditStatus');
      if (statusEl) {
        if (previewHasChanges && originalPreviewText !== null) {
          statusEl.style.display = 'block';
        } else {
          statusEl.style.display = 'none';
        }
      }
      
      // Update upload button text if changes detected
      if (previewHasChanges && filePreview && filePreview.value) {
        const parsed = parsePreviewText(filePreview.value, cycleCountFileHeader !== null);
        const editedRowCount = parsed.rows.length;
        const uploadBtn = document.getElementById('uploadCycleCountsBtn');
        if (uploadBtn && editedRowCount > 0) {
          uploadBtn.textContent = `Upload ${editedRowCount} Cycle Count${editedRowCount === 1 ? '' : 's'} (Edited)`;
        }
      } else {
        // Reset to original count
        const uploadBtn = document.getElementById('uploadCycleCountsBtn');
        if (uploadBtn && cycleCountFileData && cycleCountFileData.length > 0) {
          const rowCount = cycleCountFileData.length;
          uploadBtn.textContent = `Upload ${rowCount} Cycle Count${rowCount === 1 ? '' : 's'}`;
        }
      }
    }
    
    // Function to check if preview has been edited
    function checkPreviewChanges() {
      if (!filePreview || !originalPreviewText) {
        previewHasChanges = false;
        return false;
      }
      
      const currentText = filePreview.value;
      previewHasChanges = currentText !== originalPreviewText;
      updatePreviewEditStatus();
      return previewHasChanges;
    }
    
    // Function to print file contents to console (including header if present)
    function printFileContentsToConsole(rows, fileName, fileType = 'CSV', headerRow = null) {
      if (!consoleEl) return;
      
      logToConsole(`\n=== ${fileName} (${fileType}) ===`, 'info');
      
      // Count data rows (excluding header)
      const dataRowCount = headerRow ? rows.length : rows.length;
      logToConsole(`Total rows: ${dataRowCount}`, 'info');
      
      if (headerRow) {
        logToConsole('---', 'info');
        const headerStr = Array.isArray(headerRow) ? headerRow.join(', ') : String(headerRow);
        logToConsole(`Header: ${headerStr}`, 'info');
      }
      
      logToConsole('---', 'info');
      
      // Print first 50 rows to avoid overwhelming the console
      const maxRows = Math.min(50, rows.length);
      for (let i = 0; i < maxRows; i++) {
        const row = rows[i];
        const rowStr = Array.isArray(row) ? row.join(', ') : String(row);
        logToConsole(`Row ${i + 1}: ${rowStr}`, 'info');
      }
      
      if (rows.length > maxRows) {
        logToConsole(`... (${rows.length - maxRows} more rows)`, 'info');
      }
      logToConsole('=== End of file ===\n', 'info');
    }

    // API call function
    async function apiCall(endpoint, data) {
      try {
        logToConsole(`[API] Calling ${endpoint}...`, 'info');
        const url = `/api/${endpoint}`;
        const headers = { 'Content-Type': 'application/json' };
        if (sessionToken) {
          headers['Authorization'] = `Bearer ${sessionToken}`;
        }
        const requestOptions = {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(data)
        };
        const response = await fetch(url, requestOptions);
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        const result = await response.json();
        if (result.success) {
          logToConsole(`[API] ${endpoint} succeeded`, 'success');
        } else {
          logToConsole(`[API] ${endpoint} failed: ${result.error}`, 'error');
          }
        return result;
      } catch (error) {
        logToConsole(`[API] ${endpoint} exception: ${error.message}`, 'error');
        return { success: false, error: error.message };
      }
    }
    
    // Upload Cycle Counts function
    async function uploadCycleCounts() {
      // Check if preview has been edited and use edited data if so
      let dataToUpload = cycleCountFileData;
      let headerToUse = cycleCountFileHeader;
      
      if (checkPreviewChanges() && filePreview && filePreview.value) {
        // Parse edited preview text
        const parsed = parsePreviewText(filePreview.value, cycleCountFileHeader !== null);
        dataToUpload = parsed.rows;
        headerToUse = parsed.headerRow || cycleCountFileHeader;
        logToConsole(`Using edited preview data (${dataToUpload.length} rows)`, 'info');
      } else if (!cycleCountFileData || cycleCountFileData.length === 0) {
        alert('Please load a cycle count file first.');
        return;
      }
      
      if (!isAuthenticated || !sessionToken) {
        alert('Please authenticate first.');
        return;
      }
      
      if (!sessionOrg) {
        alert('Organization is required.');
        return;
      }
      
      const uploadBtn = document.getElementById('uploadCycleCountsBtn');
      const uploadStatus = document.getElementById('uploadStatus');
      
      // Disable button during upload
      if (uploadBtn) {
        uploadBtn.disabled = true;
        uploadBtn.textContent = 'Uploading...';
      }
      if (uploadStatus) {
        uploadStatus.textContent = '';
      }
      
      let successCount = 0;
      let failCount = 0;
      const errors = [];
      
      logToConsole(`\n=== Starting Cycle Count Upload ===`, 'info');
      logToConsole(`Total rows to process: ${dataToUpload.length}`, 'info');
      
      // Process each row sequentially
      for (let i = 0; i < dataToUpload.length; i++) {
        const row = dataToUpload[i];
        const locationId = row && row.length > 0 ? String(row[0]).trim() : '';
        const quantity = row && row.length > 1 ? String(row[1]).trim() : '';
        
        if (!locationId) {
          logToConsole(`Row ${i + 1}: Skipped - missing LocationId`, 'warning');
          failCount++;
          errors.push(`Row ${i + 1}: Missing LocationId`);
          continue;
        }
        
        // Build payload
        const payload = {
          "LocationId": locationId,
          "CountMode": "USER_DIRECTED",
          "CountSequence": 1,
          "LpnTracking": false,
          "CountCriteriaId": "Cycle Count Active-API Mode",
          "TransactionId": "Cycle Count Active-API",
          "TaskIntegrationDTO": {
            "TransactionId": "Cycle Count Active-API",
            "TransactionTypeId": "Cycle Count",
            "LaborActivityId": "Cycle Count"
          }
        };
        
        // Log API call payload
        logToConsole(`\n=== Row ${i + 1} (Location: ${locationId}) ===`, 'info');
        logToConsole(`API Call: initiateCount`, 'info');
        logToConsole(`Endpoint: /inventory-management/api/inventory-management/count/initiateCount`, 'info');
        logToConsole(`Request Payload:`, 'info');
        logToConsole(JSON.stringify(payload, null, 2), 'info');
        
        try {
          const result = await apiCall('initiateCount', {
            org: sessionOrg,
            token: sessionToken,
            payload: payload
          });
          
          // Log full response
          logToConsole(`Response:`, result.success ? 'success' : 'error');
          logToConsole(JSON.stringify(result, null, 2), result.success ? 'success' : 'error');
          
          if (result.success) {
            // First API succeeded, extract CountRunId and TaskId from response
            let countRunId = null;
            let taskId = null;
            if (result.response && typeof result.response === 'object') {
              const resp = result.response;
              // Try various possible locations for CountRunId
              if (resp.CountRunId) {
                countRunId = resp.CountRunId;
              } else if (resp.countRunId) {
                countRunId = resp.countRunId;
              } else if (resp.data && resp.data.CountRunId) {
                countRunId = resp.data.CountRunId;
              } else if (resp.data && resp.data.countRunId) {
                countRunId = resp.data.countRunId;
              } else if (resp.Data && resp.Data.CountRunId) {
                countRunId = resp.Data.CountRunId;
              } else if (resp.Data && resp.Data.countRunId) {
                countRunId = resp.Data.countRunId;
              }
              
              // Try various possible locations for TaskId
              if (resp.TaskId) {
                taskId = resp.TaskId;
              } else if (resp.taskId) {
                taskId = resp.taskId;
              } else if (resp.data && resp.data.TaskId) {
                taskId = resp.data.TaskId;
              } else if (resp.data && resp.data.taskId) {
                taskId = resp.data.taskId;
              } else if (resp.Data && resp.Data.TaskId) {
                taskId = resp.Data.TaskId;
              } else if (resp.Data && resp.Data.taskId) {
                taskId = resp.Data.taskId;
              }
            }
            
            logToConsole(`Row ${i + 1}: Successfully initiated count for Location ${locationId}`, 'success');
            if (countRunId) {
              logToConsole(`Row ${i + 1}: CountRunId extracted: ${countRunId}`, 'info');
            } else {
              logToConsole(`Row ${i + 1}: Warning - CountRunId not found in response`, 'warning');
            }
            if (taskId) {
              logToConsole(`Row ${i + 1}: TaskId extracted: ${taskId}`, 'info');
            } else {
              logToConsole(`Row ${i + 1}: Warning - TaskId not found in response`, 'warning');
            }
            
            // Second API call: Get ItemId for the location
            logToConsole(`\n=== Row ${i + 1} - Getting ItemId for Location: ${locationId} ===`, 'info');
            logToConsole(`API Call: getInventory`, 'info');
            logToConsole(`Endpoint: /dcinventory/api/dcinventory/inventory?query=LocationId="${locationId}"`, 'info');
            
            try {
              const inventoryResult = await apiCall('getInventory', {
                org: sessionOrg,
                token: sessionToken,
                locationId: locationId
              });
              
              // Log full response
              logToConsole(`Response:`, inventoryResult.success ? 'success' : 'error');
              logToConsole(JSON.stringify(inventoryResult, null, 2), inventoryResult.success ? 'success' : 'error');
              
              if (inventoryResult.success && inventoryResult.itemId) {
                const itemId = inventoryResult.itemId;
                logToConsole(`Row ${i + 1}: Found ItemId ${itemId} for Location ${locationId}`, 'success');
                
                // Third API call: Validate Item and Get Item Details
                if (countRunId) {
                  logToConsole(`\n=== Row ${i + 1} - Validating Item and Getting Item Details ===`, 'info');
                  logToConsole(`API Call: validateItemAndGetItemDetails`, 'info');
                  logToConsole(`Endpoint: /inventory-management/api/inventory-management/count/validateItemAndGetItemDetails`, 'info');
                  
                  const validatePayload = {
                    "LocationId": locationId,
                    "CountRunId": countRunId,
                    "LpnTracking": false,
                    "ContainerId": null,
                    "TransactionId": "Cycle Count Active-API",
                    "CriteriaId": "Cycle Count Active-API Mode",
                    "ItemAttributeDTO": {
                      "Item": itemId
                    },
                    "TransactionTypeId": "Cycle Count"
                  };
                  
                  logToConsole(`Request Payload:`, 'info');
                  logToConsole(JSON.stringify(validatePayload, null, 2), 'info');
                  
                  try {
                    const validateResult = await apiCall('validateItemAndGetItemDetails', {
                      org: sessionOrg,
                      token: sessionToken,
                      payload: validatePayload
                    });
                    
                    // Log full response
                    logToConsole(`Response:`, validateResult.success ? 'success' : 'error');
                    logToConsole(JSON.stringify(validateResult, null, 2), validateResult.success ? 'success' : 'error');
                    
                    if (validateResult.success) {
                      logToConsole(`Row ${i + 1}: Successfully validated item and got item details for Location ${locationId}`, 'success');
                      
                      // Fourth API call: Accept Quantity
                      if (countRunId && taskId) {
                        logToConsole(`\n=== Row ${i + 1} - Accepting Quantity ===`, 'info');
                        logToConsole(`API Call: acceptQuantity`, 'info');
                        logToConsole(`Endpoint: /inventory-management/api/inventory-management/count/acceptQuantity`, 'info');
                        
                        const acceptPayload = {
                          "LocationId": locationId,
                          "CountRunId": countRunId,
                          "ContainerType": null,
                          "ContainerId": null,
                          "Quantity": quantity ? parseFloat(quantity) : 0,
                          "BlindIlpn": false,
                          "TransactionId": "Cycle Count Active-API",
                          "TaskId": taskId,
                          "CriteriaId": "Cycle Count Active-API Mode",
                          "ItemAttributeDTO": {
                            "Item": itemId,
                            "CompareAttributes": false
                          },
                          "TaskIntegrationDTO": {
                            "TransactionId": "Cycle Count Active-API",
                            "TransactionTypeId": "Cycle Count",
                            "LaborActivityId": "Cycle Count"
                          }
                        };
                        
                        logToConsole(`Request Payload:`, 'info');
                        logToConsole(JSON.stringify(acceptPayload, null, 2), 'info');
                        
                        try {
                          const acceptResult = await apiCall('acceptQuantity', {
                            org: sessionOrg,
                            token: sessionToken,
                            payload: acceptPayload
                          });
                          
                          // Log full response (always log complete response for debugging)
                          logToConsole(`\n=== Full acceptQuantity Response ===`, 'info');
                          logToConsole(JSON.stringify(acceptResult, null, 2), 'info');
                          logToConsole(`Response success field: ${acceptResult.success}`, acceptResult.success ? 'success' : 'error');
                          
                          // Debug: Check for warning
                          const hasWarning = hasQuantityMismatchWarning(acceptResult);
                          logToConsole(`Has quantity mismatch warning: ${hasWarning}`, hasWarning ? 'warning' : 'info');
                          
                          // Check if success or if it's a WARNING about quantity mismatch (which should be treated as success)
                          const isSuccess = acceptResult.success || hasWarning;
                          logToConsole(`Final isSuccess determination: ${isSuccess}`, isSuccess ? 'success' : 'error');
                          
                          if (isSuccess) {
                            if (acceptResult.success) {
                              logToConsole(`Row ${i + 1}: Successfully accepted quantity ${quantity} for Location ${locationId}`, 'success');
                            } else {
                              // It's a warning, but we're treating it as success
                              logToConsole(`Row ${i + 1}: Accepted quantity ${quantity} for Location ${locationId} (with quantity mismatch warning)`, 'warning');
                            }
                            
                            // Fifth API call: Persist Count Details
                            // Fifth API call: Persist Count Details
                            logToConsole(`\n=== Row ${i + 1} - Persisting Count Details ===`, 'info');
                            logToConsole(`API Call: persistCountDetails`, 'info');
                            logToConsole(`Endpoint: /inventory-management/api/inventory-management/count/quantity/persistCountDetails`, 'info');
                            
                            const persistPayload = {
                              "LocationId": locationId,
                              "CountRunId": countRunId,
                              "Quantity": quantity ? parseFloat(quantity) : 0,
                              "TaskId": taskId,
                              "ContainerId": null,
                              "ContainerType": "LOCATION",
                              "TransactionId": "Cycle Count Active-API",
                              "BlindIlpn": false,
                              "CriteriaId": "Cycle Count Active-API Mode",
                              "ItemAttributeDTO": {
                                "Item": itemId,
                                "CompareAttributes": false
                              },
                              "TaskIntegrationDTO": {
                                "TransactionId": "Cycle Count Active-API",
                                "TransactionTypeId": "Cycle Count",
                                "LaborActivityId": "Cycle Count"
                              }
                            };
                            
                            logToConsole(`Request Payload:`, 'info');
                            logToConsole(JSON.stringify(persistPayload, null, 2), 'info');
                            
                            try {
                              const persistResult = await apiCall('persistCountDetails', {
                                org: sessionOrg,
                                token: sessionToken,
                                payload: persistPayload
                              });
                              
                              // Log full response
                              logToConsole(`Response:`, persistResult.success ? 'success' : 'error');
                              logToConsole(JSON.stringify(persistResult, null, 2), persistResult.success ? 'success' : 'error');
                              
                              if (persistResult.success) {
                                logToConsole(`Row ${i + 1}: Successfully persisted count details for Location ${locationId}`, 'success');
                                
                                // Sixth API call: End Count
                                logToConsole(`\n=== Row ${i + 1} - Ending Count ===`, 'info');
                                logToConsole(`API Call: endCount`, 'info');
                                logToConsole(`Endpoint: /inventory-management/api/inventory-management/count/end`, 'info');
                                
                                const endPayload = {
                                  "LocationId": locationId,
                                  "CountRunId": countRunId,
                                  "CountSequence": 1,
                                  "LpnTracking": false,
                                  "TransactionId": "Cycle Count Active-API",
                                  "CriteriaId": "Cycle Count Active-API Mode",
                                  "TaskIntegrationDTO": {
                                    "TransactionId": "Cycle Count Active-API",
                                    "TransactionTypeId": "Cycle Count",
                                    "LaborActivityId": "Cycle Count"
                                  }
                                };
                                
                                logToConsole(`Request Payload:`, 'info');
                                logToConsole(JSON.stringify(endPayload, null, 2), 'info');
                                
                                try {
                                  const endResult = await apiCall('endCount', {
                                    org: sessionOrg,
                                    token: sessionToken,
                                    payload: endPayload
                                  });
                                  
                                  // Log full response
                                  logToConsole(`Response:`, endResult.success ? 'success' : 'error');
                                  logToConsole(JSON.stringify(endResult, null, 2), endResult.success ? 'success' : 'error');
                                  
                                  if (endResult.success) {
                                    logToConsole(`Row ${i + 1}: Successfully ended count for Location ${locationId}`, 'success');
                                    successCount++;
                                  } else {
                                    failCount++;
                                    const errorMsg = endResult.error || 'Failed to end count';
                                    errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
                                    logToConsole(`Row ${i + 1}: Failed to end count for Location ${locationId}: ${errorMsg}`, 'error');
                                  }
                                } catch (error) {
                                  failCount++;
                                  const errorMsg = error.message || 'Exception occurred while ending count';
                                  errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
                                  logToConsole(`Row ${i + 1}: Error ending count - ${errorMsg}`, 'error');
                                }
                              } else {
                                failCount++;
                                const errorMsg = persistResult.error || 'Failed to persist count details';
                                errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
                                logToConsole(`Row ${i + 1}: Failed to persist count details for Location ${locationId}: ${errorMsg}`, 'error');
                              }
                            } catch (error) {
                              failCount++;
                              const errorMsg = error.message || 'Exception occurred while persisting count details';
                              errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
                              logToConsole(`Row ${i + 1}: Error persisting count details - ${errorMsg}`, 'error');
                            }
                          } else {
                            // Not success and no quantity mismatch warning - treat as failure
                            // Check if there are any ERROR type messages
                            const hasError = acceptResult.response && 
                                           acceptResult.response.messages && 
                                           acceptResult.response.messages.Message && 
                                           Array.isArray(acceptResult.response.messages.Message) &&
                                           acceptResult.response.messages.Message.some(msg => {
                                             const type = msg.Type || msg.type || '';
                                             return type.toUpperCase() === 'ERROR';
                                           });
                            
                            // If there's an ERROR or no warning found, it's a real failure
                            failCount++;
                            const errorMsg = acceptResult.error || 'Failed to accept quantity';
                            errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
                            logToConsole(`Row ${i + 1}: Failed to accept quantity for Location ${locationId}: ${errorMsg}`, 'error');
                          }
                        } catch (error) {
                          failCount++;
                          const errorMsg = error.message || 'Exception occurred while accepting quantity';
                          errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
                          logToConsole(`Row ${i + 1}: Error accepting quantity - ${errorMsg}`, 'error');
                        }
                      } else {
                        failCount++;
                        const missingFields = [];
                        if (!countRunId) missingFields.push('CountRunId');
                        if (!taskId) missingFields.push('TaskId');
                        const errorMsg = `Missing required fields: ${missingFields.join(', ')}`;
                        errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
                        logToConsole(`Row ${i + 1}: Cannot proceed - ${errorMsg}`, 'error');
                      }
                    } else {
                      failCount++;
                      const errorMsg = validateResult.error || 'Failed to validate item';
                      errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
                      logToConsole(`Row ${i + 1}: Failed to validate item for Location ${locationId}: ${errorMsg}`, 'error');
                    }
                  } catch (error) {
                    failCount++;
                    const errorMsg = error.message || 'Exception occurred while validating item';
                    errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
                    logToConsole(`Row ${i + 1}: Error validating item - ${errorMsg}`, 'error');
                  }
                } else {
                  failCount++;
                  const errorMsg = 'CountRunId not found in initiateCount response';
                  errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
                  logToConsole(`Row ${i + 1}: Cannot proceed - ${errorMsg}`, 'error');
                }
              } else {
                failCount++;
                const errorMsg = inventoryResult.error || 'Failed to get ItemId';
                errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
                logToConsole(`Row ${i + 1}: Failed to get ItemId for Location ${locationId}: ${errorMsg}`, 'error');
              }
            } catch (error) {
              failCount++;
              const errorMsg = error.message || 'Exception occurred while getting ItemId';
              errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
              logToConsole(`Row ${i + 1}: Error getting ItemId - ${errorMsg}`, 'error');
            }
          } else {
            failCount++;
            const errorMsg = result.error || 'Unknown error';
            errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
            logToConsole(`Row ${i + 1}: Failed to initiate count for Location ${locationId}: ${errorMsg}`, 'error');
          }
        } catch (error) {
          failCount++;
          const errorMsg = error.message || 'Exception occurred';
          errors.push(`Row ${i + 1} (${locationId}): ${errorMsg}`);
          logToConsole(`Row ${i + 1}: Error - ${errorMsg}`, 'error');
        }
      }
      
      // Summary
      logToConsole(`\n=== Upload Complete ===`, 'info');
      logToConsole(`Success: ${successCount}`, 'success');
      logToConsole(`Failed: ${failCount}`, failCount > 0 ? 'error' : 'info');
      
      if (errors.length > 0) {
        logToConsole(`Errors:`, 'error');
        errors.forEach(err => logToConsole(`  - ${err}`, 'error'));
      }
      
      // Update UI
      if (uploadBtn) {
        uploadBtn.disabled = false;
        // Update button text to reflect actual upload results
        if (successCount > 0) {
          uploadBtn.textContent = `Upload ${successCount} Cycle Count${successCount === 1 ? '' : 's'}`;
        } else if (cycleCountFileData && cycleCountFileData.length > 0) {
          const rowCount = cycleCountFileData.length;
          uploadBtn.textContent = `Upload ${rowCount} Cycle Count${rowCount === 1 ? '' : 's'}`;
        } else {
          uploadBtn.textContent = 'Upload Cycle Counts';
        }
      }
      if (uploadStatus) {
        if (failCount === 0) {
          const countText = successCount === 1 ? 'cycle count' : 'cycle counts';
          uploadStatus.textContent = `✓ Successfully uploaded ${successCount} ${countText}`;
          uploadStatus.style.color = '#ffffff'; // White color
        } else {
          uploadStatus.textContent = `${successCount} succeeded, ${failCount} failed`;
          uploadStatus.style.color = '#ffffff'; // White color
        }
      }
    }

    // Update UI based on authentication status
    function updateAuthUI() {
      const authSection = document.getElementById('authSection');
      const mainContent = document.getElementById('mainContent');
      const authStatus = document.getElementById('authStatus');
      const authError = document.getElementById('authError');
      const orgInput = document.getElementById('orgInput');
      const authBtn = document.getElementById('authBtn');

      if (isAuthenticated) {
        // Hide auth section, show main content
        if (authSection) authSection.style.display = 'none';
        if (mainContent) mainContent.style.display = 'block';
        if (authStatus) authStatus.textContent = `Authenticated as: ${sessionOrg}`;
        if (authError) authError.style.display = 'none';
      } else {
        // Show auth section, hide main content
        if (authSection) authSection.style.display = 'block';
        if (mainContent) mainContent.style.display = 'none';
        if (authStatus) authStatus.textContent = '';
        if (authError) authError.style.display = 'none';
        if (orgInput) orgInput.disabled = false;
        if (authBtn) authBtn.disabled = false;
      }
    }

    // Handle authentication
    async function authenticate(org) {
      if (!org || !org.trim()) {
        const authError = document.getElementById('authError');
        if (authError) {
          authError.textContent = 'Please enter an Organization';
          authError.style.display = 'block';
        }
        return false;
      }

      const orgInput = document.getElementById('orgInput');
      const authBtn = document.getElementById('authBtn');
      const authStatus = document.getElementById('authStatus');
      const authError = document.getElementById('authError');

      // Disable inputs during authentication
      if (orgInput) orgInput.disabled = true;
      if (authBtn) authBtn.disabled = true;
      if (authStatus) authStatus.textContent = 'Authenticating...';
      if (authError) authError.style.display = 'none';

      try {
        const result = await apiCall('auth', { org: org.trim() });
        
        if (result.success) {
          sessionOrg = org.trim();
          sessionToken = result.token;
          isAuthenticated = true;
          logToConsole(`Authentication successful for ORG: ${sessionOrg}`, 'success');
          updateAuthUI();
          return true;
          } else {
          isAuthenticated = false;
          sessionOrg = null;
          sessionToken = null;
          const errorMsg = result.error || 'Authentication failed';
          logToConsole(`Authentication failed: ${errorMsg}`, 'error');
          if (authError) {
            authError.textContent = errorMsg;
            authError.style.display = 'block';
          }
          if (authStatus) authStatus.textContent = '';
          updateAuthUI();
          return false;
        }
      } catch (error) {
        isAuthenticated = false;
        sessionOrg = null;
        sessionToken = null;
        logToConsole(`Authentication error: ${error.message}`, 'error');
        if (authError) {
          authError.textContent = `Error: ${error.message}`;
          authError.style.display = 'block';
        }
        if (authStatus) authStatus.textContent = '';
        updateAuthUI();
        return false;
      } finally {
        if (orgInput) orgInput.disabled = false;
        if (authBtn) authBtn.disabled = false;
      }
    }

    // Theme selector elements (will be initialized after DOM loads)
    let themeSelectorBtn = null;
    let themeModal = null;
    let themeList = null;

    // THEME DEFINITIONS
    const themes = {
      'dark': {
        name: 'Dark',
        colors: {
          '--bg-dark': '#121212',
          '--card-bg': '#1e1e1e',
          '--input-bg': '#2d2d2d',
          '--border': '#333',
          '--text': '#e0e0e0',
          '--text-secondary': '#bbbbbb',
          '--text-muted': '#999',
          '--red-bg': '#4a1a1a',
          '--red-text': '#ff6b6b',
          '--blue-select': '#339af0',
          '--success': '#28a745',
          '--primary': '#0d6efd',
          '--primary-hover': '#0b5ed7',
          '--success-hover': '#218838',
          '--table-header-bg': '#2a2a2a',
          '--table-header-text': '#e0e0e0',
          '--input-border': '#444',
          '--input-focus-bg': '#333',
          '--input-focus-border': '#0d6efd',
          '--input-focus-shadow': 'rgba(13, 110, 253, 0.25)',
          '--orange': '#e67700',
          '--purple': '#9c27b0'
        }
      },
      'manhattan': {
        name: 'Manhattan',
        colors: {
          '--bg-dark': 'rgb(45, 47, 59)',
          '--card-bg': '#484e5e',
          '--input-bg': '#282c34',
          '--border': '#333',
          '--text': '#495057',
          '--text-secondary': '#bbbbbb',
          '--text-muted': '#999',
          '--red-bg': '#4a1a1a',
          '--red-text': '#ff6b6b',
          '--blue-select': '#339af0',
          '--success': 'hsl(142.1 76.2% 36.3%)',
          '--primary': '#3B82F6',
          '--primary-hover': '#2563eb',
          '--success-hover': '#218838',
          '--table-header-bg': '#2a2a2a',
          '--table-header-text': '#e0e0e0',
          '--input-border': '#444',
          '--input-focus-bg': '#333',
          '--input-focus-border': '#3B82F6',
          '--input-focus-shadow': 'rgba(59, 130, 246, 0.25)',
          '--orange': '#e67700',
          '--purple': '#9c27b0',
          '--secondary': '#6c757d',
          '--shadow': '0 4px 12px rgba(0,0,0,0.3)'
        }
      }
    };

    // THEME FUNCTIONS
    function applyTheme(themeKey) {
      const theme = themes[themeKey];
      if (!theme) return;

      const root = document.documentElement;
      Object.entries(theme.colors).forEach(([property, value]) => {
        root.style.setProperty(property, value);
      });

      // Save to localStorage
      localStorage.setItem('selectedTheme', themeKey);
    }

    function loadTheme() {
      const savedTheme = localStorage.getItem('selectedTheme') || 'dark';
      applyTheme(savedTheme);
    }

    function renderThemeList() {
      if (!themeList) return;
      themeList.innerHTML = '';
      const currentTheme = localStorage.getItem('selectedTheme') || 'dark';
      
      Object.entries(themes).forEach(([key, theme]) => {
        const item = document.createElement('button');
        item.type = 'button';
        item.className = `list-group-item list-group-item-action ${key === currentTheme ? 'active' : ''}`;
        item.textContent = theme.name;
        item.onclick = () => {
          applyTheme(key);
          themeModal.hide();
        };
        themeList.appendChild(item);
      });
    }

    // Initialize theme selector (called after DOM loads)
    function initializeThemeSelector() {
      themeSelectorBtn = document.getElementById('themeSelectorBtn');
      const themeModalElement = document.getElementById('themeModal');
      if (themeModalElement) {
        themeModal = new bootstrap.Modal(themeModalElement);
      }
      themeList = document.getElementById('themeList');
      
      if (themeSelectorBtn) {
        themeSelectorBtn.onclick = () => {
          renderThemeList();
          if (themeModal) themeModal.show();
        };
      }
    }

    // Register event handlers
    function registerEventHandlers() {
      const authBtn = document.getElementById('authBtn');
      const orgInput = document.getElementById('orgInput');

      if (authBtn) {
        authBtn.addEventListener('click', async () => {
          const org = orgInput ? orgInput.value : '';
          await authenticate(org);
        });
      }

      if (orgInput) {
        orgInput.addEventListener('keypress', async (e) => {
          if (e.key === 'Enter') {
            await authenticate(orgInput.value);
          }
        });
      }
      
      // Cycle Count file picker button
      if (cycleCountFileLoadBtn && cycleCountFileInput) {
        cycleCountFileLoadBtn.addEventListener('click', () => {
          cycleCountFileInput.click();
        });
      }
      
      // Cycle Count file change handler
      if (cycleCountFileInput) {
        cycleCountFileInput.addEventListener('change', async (e) => {
          if (!e.target.files.length) {
            cycleCountFileData = null;
            cycleCountFileHeader = null;
            setCycleCountFileStatus('');
            updateFilePreview(null);
            const uploadButtonSection = document.getElementById('uploadButtonSection');
            if (uploadButtonSection) {
              uploadButtonSection.style.display = 'none';
            }
            if (cycleCountFileDisplay) {
              cycleCountFileDisplay.value = '';
              updateFileInputShading(cycleCountFileDisplay, true);
            }
            return;
          }
          
          const file = e.target.files[0];
          const fileName = file.name;
          
          // Validate file format before loading
          const validation = await validateCycleCountFile(file);
          
          if (!validation.valid) {
            // Show error message
            setCycleCountFileStatus('');
            
            if (cycleCountFileDisplay) {
              cycleCountFileDisplay.value = '';
              cycleCountFileDisplay.removeAttribute('title');
              // Restore red shading to indicate file needs to be loaded
              updateFileInputShading(cycleCountFileDisplay, true);
            }
            
            // Clear cycle count file data
            cycleCountFileData = null;
            cycleCountFileHeader = null;
            updateFilePreview(null);
            const uploadButtonSection = document.getElementById('uploadButtonSection');
            if (uploadButtonSection) {
              uploadButtonSection.style.display = 'none';
            }
            e.target.value = '';
            alert(`Invalid file format: ${validation.error}`);
            return;
          }
          
          // File is valid, parse and store data
          try {
            const parseResult = await parseCycleCountFile(file);
            cycleCountFileData = parseResult.rows;
            cycleCountFileHeader = parseResult.headerRow || null;
            const headerDetected = parseResult.headerDetected;
            
            // Update display textbox - show only filename
            if (cycleCountFileDisplay) {
              cycleCountFileDisplay.value = fileName;
              cycleCountFileDisplay.title = fileName; // Tooltip shows filename on hover
              // Remove red shading when file is loaded
              updateFileInputShading(cycleCountFileDisplay, false);
            }
            
            // Use validation count if available, otherwise use parsed rows count
            const rowCount = validation.rowCount || cycleCountFileData.length;
            const statusMessage = rowCount > 0
              ? headerDetected
                ? `${rowCount} rows loaded (header row detected and skipped)`
                : `${rowCount} rows loaded`
              : 'No data rows detected.';
            setCycleCountFileStatus(statusMessage);
            
            // Log to console
            if (headerDetected) {
              logToConsole(`Cycle Count file: Header row detected and skipped (${rowCount} data rows)`, 'info');
            } else {
              logToConsole(`Cycle Count file: ${rowCount} rows loaded from file`, 'success');
            }
            
            // Update file preview window
            updateFilePreview(cycleCountFileData, cycleCountFileHeader);
            
            // Show upload button if file is loaded
            const uploadButtonSection = document.getElementById('uploadButtonSection');
            const uploadBtn = document.getElementById('uploadCycleCountsBtn');
            if (uploadButtonSection) {
              uploadButtonSection.style.display = 'block';
            }
            // Update button text with row count
            if (uploadBtn && cycleCountFileData) {
              const rowCount = cycleCountFileData.length;
              uploadBtn.textContent = `Upload ${rowCount} Cycle Count${rowCount === 1 ? '' : 's'}`;
            }
            
            // Print file contents to console (including header)
            const extension = file.name.split('.').pop().toLowerCase();
            const fileType = extension === 'csv' || extension === 'txt' ? (extension === 'txt' ? 'TXT' : 'CSV') : 'Excel';
            printFileContentsToConsole(cycleCountFileData, fileName, fileType, cycleCountFileHeader);
            
            // Clear the file input value so the same file can be reloaded
            e.target.value = '';
          } catch (error) {
            // File parsing failed - show error and restore red shading
            setCycleCountFileStatus('');
            
            if (cycleCountFileDisplay) {
              cycleCountFileDisplay.value = '';
              cycleCountFileDisplay.removeAttribute('title');
              // Restore red shading to indicate file needs to be loaded
              updateFileInputShading(cycleCountFileDisplay, true);
            }
            
            // Clear cycle count file data
            cycleCountFileData = null;
            cycleCountFileHeader = null;
            updateFilePreview(null);
            const uploadButtonSection = document.getElementById('uploadButtonSection');
            if (uploadButtonSection) {
              uploadButtonSection.style.display = 'none';
            }
            e.target.value = '';
            const errorMsg = error.message || 'Failed to parse file. Please ensure the file is a valid CSV, Excel, or TXT file.';
            alert(`Error loading file: ${errorMsg}`);
          }
        });
      }
      
      // File Preview change detection
      if (filePreview) {
        filePreview.addEventListener('input', () => {
          checkPreviewChanges();
        });
        filePreview.addEventListener('paste', () => {
          // Use setTimeout to check after paste completes
          setTimeout(() => {
            checkPreviewChanges();
          }, 10);
        });
      }
      
      // Upload Cycle Counts button handler
      const uploadCycleCountsBtn = document.getElementById('uploadCycleCountsBtn');
      if (uploadCycleCountsBtn) {
        uploadCycleCountsBtn.addEventListener('click', uploadCycleCounts);
      }
      
      // Console toggle button
      if (consoleToggleBtn) {
        consoleToggleBtn.addEventListener('click', () => {
          if (consoleSection) {
            const isHidden = consoleSection.style.display === 'none' || !consoleSection.style.display;
            consoleSection.style.display = isHidden ? 'block' : 'none';
          }
        });
      }
      
      // Console close button
      if (consoleCloseBtn) {
        consoleCloseBtn.addEventListener('click', () => {
          if (consoleSection) {
            consoleSection.style.display = 'none';
          }
        });
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      logToConsole(`Cycle Count ${APP_VERSION} initialized`, 'success');
      
      // Load theme on page load
      loadTheme();
      
      // Initialize theme selector
      initializeThemeSelector();
      
      // Register event handlers
      registerEventHandlers();
      
      // Initialize file input shading on load
      if (cycleCountFileDisplay) {
        updateFileInputShading(cycleCountFileDisplay, true);
      }
      
      // Initialize UI state
      updateAuthUI();
      
      // Check for Organization parameter in URL and auto-authenticate
      if (urlOrg && urlOrg.trim()) {
        logToConsole(`Organization parameter detected in URL: ${urlOrg.trim()}. Auto-authenticating...`, 'info');
        
        // Populate the input field
        const orgInput = document.getElementById('orgInput');
        if (orgInput) {
          orgInput.value = urlOrg.trim();
        }
        
        // Auto-authenticate
        authenticate(urlOrg.trim()).then(success => {
          if (success) {
            logToConsole(`Auto-authentication successful for Organization: ${sessionOrg}`, 'success');
        } else {
            logToConsole(`Auto-authentication failed for Organization: ${urlOrg.trim()}`, 'error');
            const authError = document.getElementById('authError');
            if (authError) {
              authError.style.display = 'block';
            }
          }
        });
      }
      
      // Check for Console parameter and show console if Console=Y
      if (urlConsole && urlConsole.toUpperCase() === 'Y') {
        if (consoleSection) {
          consoleSection.style.display = 'block';
          logToConsole('Console window opened via URL parameter (Console=Y)', 'info');
        }
      }
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
